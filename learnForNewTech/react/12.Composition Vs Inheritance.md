## 文档
<https://reactjs.org/docs/composition-vs-inheritance.html>

## Composition Vs Inheritance: 组合和继承

React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components.

React具有强大的组合模型，我们推荐使用组合而非继承来重用组件之间的代码。

### Containment：包含
Some components don’t know their children ahead of time. This is especially common for components like Sidebar or Dialog that represent generic “boxes”.

一些组件并不会提前获知它们的孩子组件。对于一些通用的"boxes"，如"边栏"或"对话框"，这是非常常见的。

We recommend that such components use the special children prop to pass children elements directly into their output:

我们推荐这种组件使用特殊的"children" prop将children elements直接传递到它们的输出中：

```
function FancyBorder(props) {
  return (
    <div className={'FancyBorder FancyBorder-' + props.color}>
      {props.children}
    </div>
  )
}
```

This lets other components pass arbitrary children to them by nesting the JSX:

这可以让其他组件通过嵌套JSX来传递任意children元素：


```
function WelcomeDialog() {
  return (
    <FancyBorder color="blue">
      <h1 className="Dialog-title">
        Welcome
      </h1>
      <p className="Dialog-message">
        Thank you for visiting our spacecraft!
      </p>
    </FancyBorder>
  )
}
```
***（已实操）***

Anything inside the <FancyBorder> JSX tag gets passed into the FancyBorder component as a children prop. Since FancyBorder renders {props.children} inside a < div>, the passed elements appear in the final output.

任何在< FancyBorder> JSX标签内的东西都会作为一个children prop传入到FancyBorder组件中。 由于FancyBorder在< div>内呈现{props.children}，传递的元素会出现在最终的输出中。

While this is less common, sometimes you might need multiple “holes” in a component. In such cases you may come up with your own convention instead of using children:

虽然这种情况不太常见，但是有时您可能需要在组件中设置个“洞”。 在这种情况下，你可以拿出你自己的习惯而不是使用children：

```
function SplitPane(props) {
  return (
    <div className="SplitPane">
      <div className="SplitPane-left">
        {props.left}
      </div>
      <div className="SplitPane-right">
        {props.right}
      </div>
    </div>
  );
}
function Contacts() {
  return <div className="Contacts" />;
}

function Chat() {
  return <div className="Chat" />;
}

function App() {
  return (
    <SplitPane left={<Contacts />} right={<Chat />} />
  );
}
```

React elements like <Contacts /> and <Chat /> are just objects, so you can pass them as props like any other data. This approach may remind you of “slots” in other libraries but there are no limitations on what you can pass as props in React.

像<Contacts />和<Chat />这样的React组件只是对象，所以你可以像任何其他数据一样将它们作为props来传递。 这种方法可能会提醒您其他库中的“插槽”，但是对于React中可以传递的props是没有限制的。

### Specialization