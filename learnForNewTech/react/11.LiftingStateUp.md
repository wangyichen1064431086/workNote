## 文档
<https://reactjs.org/docs/lifting-state-up.html>

## Lifting State Up:状态提升
Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. Let’s see how this works in action.

经常会有这样的需求，几个组件需要反映相同的变化的数据。我们推荐将共享的state提升到它们最近的祖先。我们看看实践中这是如何工作的。

In this section, we will create a temperature calculator that calculates whether the water would boil at a given temperature.

在本节中，我们将创建一个温度计算，它可以计算在给定温度下水是否会沸腾。

We will start with a component called BoilingVerdict. It accepts the celsius temperature as a prop, and prints whether it is enough to boil the water:

我们从一个叫做BoilingVerdict的组件开始。它接受摄氏温度作一个prop，并打印出它是否足够煮沸水。

```
function BoilingVerdict(props) {
  if(props.celsius >= 100) {
    return <p>The water would boil.</p> ;
  }
  return <p>The water would not boil.</p>;
}
```

Next, we will create a component called Calculator. It renders an < input> that lets you enter the temperature, and keeps its value in this.state.temperature.

接着，我们将创建一个叫做Calculator的component。它渲染一个input，它会允许你输入temperature,并将它的value保存在this.state.temperature。

Additionally, it renders the BoilingVerdict for the current input value.

此外，它将用当前的input值渲染BoilingVerdict。

```
class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature:''};
  }

  handleChange(e) {
    this.setState({
      temperature:e.target.value
    });
  }

  render() {
    const temperature = this.state.temperature;
    return (
      <fieldset>
        <legend>Enter temperature in Celsius:</legend>
        <input value={temperature} onChange={this.handleChange} />
        <BoilingVerdict celsius={parseFloat(temperature)} />
      </fieldset>
    );
  }
}
```

### Adding a Second Input
Our new requirement is that, in addition to a Celsius input, we provide a Fahrenheit input, and they are kept in sync.

我们的新需求是，除了摄氏度输入，我们还提供一个华氏度输入，并保持同步。

We can start by extracting a TemperatureInput component from Calculator. We will add a new scale prop to it that can either be "c" or "f":
 
我们可以从从Calculator组件中提取TemperatureInput组件开始。我们将会为其添加一个新的scale prop，它可以是"c"或"f"：

```
const scaleNames = {
  c:'Celsius',
  f:'Fahrenheit'
};

class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: ''};
  }
  handleChange(e) {
    this.setState({
      temperature: e.target.value
    });
  }
  render() {
    const temperature = this.state.temperature;
    const scale = this.props.scale;
    return (
      <fieldset>
        <legend>Enter temperature in {scaleNames[scale]}</legend>
        <input value={temperature} onChange={this.handleChange} />
      </fieldset>
    );
  }
}
```

We can now change the Calculator to render two separate temperature inputs:
```
class Calculator extends React.Component {
  render() {
    return (
      <div>
        <h1>Hello! This is a Temprature Caculator.</h1>
        <TemperatureInput scale="c" />
        <TemperatureInput scale="f" />
      </div>
    );
  }
}
```

We have two inputs now, but when you enter the temperature in one of them, the other doesn’t update. This contradicts our requirement: we want to keep them in sync.

我们现在有两个inputs了，但是当你在其中一个中输入temperature,另外一个并不会更新。这与我们的需求相矛盾：我们希望它们保持同步。

We also can’t display the BoilingVerdict from Calculator. The Calculator doesn’t know the current temperature because it is hidden inside the TemperatureInput.

我们也没能在Calculator中展现BoilingVerdict。

### Writing Conversion Functions
First, we will write two functions to convert from Celsius to Fahrenheit and back:

首先，我们将写两个Celsius到Fahrenheit、Fahrenheit到Celsius的转换函数：

```
function toCelsius(fahrenheit) {
  return (fahrenheit - 32) * 5 / 9;
}
function toFahrenheit(celsius) {
  return (celsius * 9 / 5) + 32;
}
```

These two functions convert numbers. We will write another function that takes a string temperature and a converter function as arguments and returns a string. We will use it to calculate the value of one input based on the other input.

这两个函数转换numbers。我们将写另外一个函数，它以一个温度字符串和一个转换函数作为参数，并返回一个字符串。我们将使用它基于一个input值计算另一个input值。

It returns an empty string on an invalid temperature, and it keeps the output rounded to the third decimal place:

```
function tryConvert(temperature, convert) {
  const input = parseFloat(temperature);
  if (Number.isNaN(input)) { //无效的输入，会返回一个空字符串
    return  '';
  }
  const output = convert(input);
  const rounded = Math.round(output * 1000) /1000;//将输入四舍五入到小数点后三位。
  return rounded.toString();
}
```

For example, tryConvert('abc', toCelsius) returns an empty string, and tryConvert('10.22', toFahrenheit) returns '50.396'.

### Lifting State Up
Currently, both TemperatureInput components independently keep their values in the local state:

目前，两个TemperatureInput组件还是在它们自己的state中独立地保持它们的values值。

However, we want these two inputs to be in sync with each other. When we update the Celsius input, the Fahrenheit input should reflect the converted temperature, and vice versa.

然而，我们希望这两个inputs彼此保持同步。当我们更新Celsius input值时，Fahrenheit input值应该反映出转换过的温度值，反之亦然。

In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called “lifting state up”. We will remove the local state from the TemperatureInput and move it into the Calculator instead.

在React中，实现共享state是通过将它提升到最近的共通祖先components。这叫做“提升state”。我们将要移除TemperatureInut本地的state，并将其移动至Calculator。

If the Calculator owns the shared state, it becomes the “source of truth” for the current temperature in both inputs. It can instruct them both to have values that are consistent with each other. Since the props of both TemperatureInput components are coming from the same parent Calculator component, the two inputs will always be in sync.

如果Calculator拥有共享state，它就会变成两个inputs的当前temperature值的“实际来源”。它可以命令它们俩的值互相保持一致。因为这两个TemperatureInput组件的props都来自同一个祖先 —— Calculator组件，这两个inputs将总是保持同步。

Let’s see how this works step by step.

我们来一步一步地看看这怎么实现。

First, we will replace this.state.temperature with this.props.temperature in the TemperatureInput component. For now, let’s pretend this.props.temperature already exists, although we will need to pass it from the Calculator in the future:

首先，在TemperatureInput组件中，我们将用this.props.temperature替换this.state.temparature。目前，我们假设this.props.temperature已经存在 —— 即使我们未来还需要从Calculator中传递出它。

```
render() {
    // Before: const temperature = this.state.temperature;
    const temperature = this.props.temperature;
    // ...
```

We know that props are read-only. When the temperature was in the local state, the TemperatureInput could just call this.setState() to change it. However, now that the temperature is coming from the parent as a prop, the TemperatureInput has no control over it.

我们知道props是只读的([props are read-only](https://reactjs.org/docs/components-and-props.html#props-are-read-only)即此处笔记5.ComponentsAndPros.md)。当temperature位于本地的state中，TemperatureInput可以通过调用this.setState()改变它。然而，现在temperature是作为prarent的一个prop,该TemperatureInput并不能控制它。

In React, this is usually solved by making a component “controlled”. Just like the DOM < input> accepts both a value and an onChange prop, so can the custom TemperatureInput accept both temperature and onTemperatureChange props from its parent Calculator.

在React中，这通常通过使组件“受控”（即受控组件）来解决。 就像DOM < input>同时接受一个 value和一个onChange prop一样，定制的TemperatureInput也可以从它的parent Calculator接受temparature和onTemperatureChange props。

```
handleChange(e) {
    // Before: this.setState({temperature: e.target.value});
    this.props.onTemperatureChange(e.target.value);
    // ...
```

> ***Note:***
> There is no special meaning to either temperature or onTemperatureChange prop names in custom components. We could have called them anything else, like name them value and onChange which is a common convention.

> ***注:***
> 自定义组件中的temperature或onTemperatureChange 属性名称（prop names）没有特殊的含义。 我们可以叫他们任何其他的名称，比如把它们命名为value和onChange，这是一个常见的惯例做法。

The onTemperatureChange prop will be provided together with the temperature prop by the parent Calculator component. It will handle the change by modifying its own local state, thus re-rendering both inputs with the new values. We will look at the new Calculator implementation very soon.

parent Calculator组件将提供onTemperatureChange prop与temperature prop。 它将通过修改自己的本地state来处理更改，从而使用新值重新渲染两个inputs。 我们将很快看到新的Calculator实现。

Before diving into the changes in the Calculator, let’s recap our changes to the TemperatureInput component. We have removed the local state from it, and instead of reading this.state.temperature, we now read this.props.temperature. Instead of calling this.setState() when we want to make a change, we now call this.props.onTemperatureChange(), which will be provided by the Calculator:

在深入计算器的变化之前，让我们回顾一下TemperatureInput组件的变化。 我们已经从中删除了本地state，我们现在读取的是this.props.temperature而不是this.state.temperature。 在想要改变的时候，我们现在调用的是Calculator提供的this.props.onTemperatureChange()函数，而不是调用this.setState()。

完整的代码：
```
const scaleNames = {
  c:'Celsius',
  f:'Fahrenheit'
};

class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
  }
  handleChange(e) {
    this.props.onTemperatureChange(e.target.value);
  }
  render() {
    const temperature = this.props.temperature;
    const scale = this.props.scale;
    return (
      <fieldset>
        <legend>Enter temperature in {scaleNames[scale]}</legend>
        <input value={temperature} onChange={this.handleChange} />
      </fieldset>
    );
  }
}

function toCelsius(fahrenheit) {
  return (fahrenheit - 32) * 5 / 9;
}
function toFahrenheit(celsius) {
  return (celsius * 9 / 5) + 32;
}

function tryConvert(temperature, convert) {
  const input = parseFloat(temperature);
  if (Number.isNaN(input)) { //无效的输入，会返回一个空字符串
    return  '';
  }
  const output = convert(input);
  const rounded = Math.round(output * 1000) /1000;//将输入四舍五入到小数点后三位。
  return rounded.toString();
}
class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);
    this.handleFahrenheitChange.bind(this);
    this.state = {
      temperature:'',
      scale:'c'
    };
  }
  handleCelsiusChange(temperature) {
    this.setState({
      scale: 'c',
      temperature
    });
  }
  handleFahrenheitChange(temperature) {
    this.setState({
      scale: 'f',
      temperature
    })
  }
  render() {
    const scale = this.state.scale;
    const temperature = this.state.temperature;
    const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
    const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;

    return (
      <div>
        <h1>Hello! This is a Temprature Caculator.</h1>
        <TemperatureInput scale="c" temperature={celsius} onTemperatureChange={this.handleCelsiusChange} />
        <TemperatureInput scale="f" temperature={fahrenheit} onTemperatureChange={this.handleFahrenheitChange} />
        <BoilingVerdict celsius={parseFloat(celsius)} />
      </div>
    );
  }
}
```
