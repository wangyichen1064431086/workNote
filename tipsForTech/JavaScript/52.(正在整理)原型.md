## 一、原型模式 
面向对象的语言可以通过类创建任意多个具有相同属性和方法的对象。ECMAScript中没有类的概念（在ES6的class之前），但是它的 **对象**是基于**引用类型**创建的，可以在一定程度上充当"类“的角色。

JavaScript创建对象最常用的方法是使用 **Object构造函数**（即通过new Object())或 **对象字面量**。但它们有个明显缺点：如果创建的一堆对象中都含有相同的方法，那么就会重复写大量重复的代码。所以会采用 **工厂模式**、**构造函数模式** 、**原型模式**等设计模式来创建对象。其中 **原型模式**是本文需要着重分析的。

### 1.原型模式使用实例
Eg1:

```js
function Person() {
}

Person.prototype.name = "Bonnie";
Person.prototype.age = 26;
Person.prototype.sayName = function() {
  console.log(this.name)
}

var person1 = new Person();
var person2 = new Person();

console.log(person1.sayName === person2.sayName);//true
```

### 2. 原型模式相关概念理解

#### (1)构造函数
构造函数是专门用来创建对象的函数，其本身也是函数。构造函数始终都应该以一个大写字母开头。

要使用构造函数创建新实例，必须使用new操作符。

#### (2)prototype属性：属于构造函数，指向原型对象
无论何时何地，只要创建了一个函数，那么该函数就会获得一个prototype属性，这个prototype属性是一个指针，指向该函数的 **原型对象**。

#### (3)原型对象
原型对象的用途是它包含了可以由 **特定类型的所有实例（即由同一个构造函数创建的实例）共享的属性和方法**。

#### (4)constructor属性：属于原型对象，指向构造函数
默认情况下，原型对象都会自动获得一个constructor属性，这个constructor属性是一个指针，指向构造函数。

#### (5)实例
实例是通过构造函数通过new操作符创建的对象。

#### (6)__proto__：属于实例，指向原型对象
通过构造函数创建的实例会包含一个__proto__属性，这个__proto__属性是一个指针，指向构造函数的 **原型对象**。

***NOTE:*** 这个属性其实被称为[[Prototype]],在js中无标准方式访问。在Firefox、Safari、Chrome中js可以通过__proto__属性访问，在其它地方没有办法访问。

构造函数、原型对象、实例的关系可以用下图表示：

<img src='./img/prototype1.png'>

具体到上Eg1，可以用下图表示:

<img src='./img/prototype2.png'>

### 3.原型模式相关规律

#### （1）实例属性会屏蔽原型属性

如果在实例中添加了一个属性，该属性与原型中的一个属性同名，那么就会在该实例中创建该属性，**该属性会屏蔽原型中的同名属性**，但 **不会修改原型中的同名属性，即使将该属性设为null**。

使用delete操作符删除实例中的属性后，**实例就恢复了对原型中同名属性的连接**。


Eg2:

```js
function Person() {
}

Person.prototype.name = "Bonnie";
Person.prototype.age = 26;
Person.prototype.sayName = function() {
  console.log(this.name)
}

var person1 = new Person();
var person2 = new Person();

person1.name = 'Summer';
console.log(person1.name);//'Summer'
console.log(person2.name);//'Bonnie'
```
#### (2) 重写整个原型对象，原型对象会丧失constructor属性的指向

```js
function Person() {
}

Person.prototype = {
  name:'Bonnie',
  age:26,
  sayName:function() {
    console.log(this.name);
  }
}

var person3 = new Person();
person3.constructor === Person;//false NOTE:实例会继承原型对象上的constructor方法。

```

如下重新调整constructor:

```js
Person.prototype.constructor = Person;
person3.constructor === Person;//true

//但是这样会使constructor属性变为可枚举属性
Object.getOwnPropertyNames(Person.prototype);//["name", "age", "sayName", "constructor"]
//Object.getOwnPropertyNames包含不可枚举属性
Object.keys(Person.prototype);// ["name", "age", "sayName", "constructor"]
//Object.keys不包含不可枚举属性
```

更好的办法是这样调整constructor:

```js
Object.defineProperty(Person.prototype, 'constructor',{
  enumerable: false,
  value: Person
});
person3.constructor === Person;//true

Object.getOwnPropertyNames(Person.prototype);//["name", "age", "sayName", "constructor"]
Object.keys(Person.prototype);//["name", "age", "sayName"]
```

#### (3)原型的动态性

对原型对象在任何时候所做的任何修改都能立即从实例中反映出来。

先创建实例再修改原型:

```js
var person4 = new Person();
person4.sayHello();//Uncaught TypeError:person4.sayHello is not a function
Person.prototype.sayHello = function() {
  console.log('hello!');
}
person4.sayHello();//hello
```

但是 **如果对原型对象进行整个重写**，那么就切断了实例与原型对象的联系，即 **实例的__proto__指针不再指向原型对象**。

```js
var person5 = new Person();
person5.sayHi();//Uncaught TypeError:person4.sayHi is not a function

Person.prototype = {
  name:'Bonnie',
  age:26,
  sayName: function() {
    console.log(this.name)
  },
  sayHi: function() {
    console.log('hi~');
  }
}

person5.sayHi();//Uncaught TypeError:person4.sayHi is not a function

```

#### (4)原型模式具有共享本性，不但共享方法，也会共享属性（不合理）

如果共享的是基本值，那么通过在实例上添加同名属性，可以覆盖原型中的同名属性。

但是如果共享的是引用类型值（如数组），那么在一个实例上修改，也会影响到其他属性。


### 4. 原型模式相关方法

#### （1）原型对象.isPrototypeOf(实例)

验证某原型对象是否为某实例的原型对象。

```js
Person.prototype.isPrototypeOf(person1);// true
```

#### (2)Object.getPrototypeOf(实例)

获取实例的原型对象。

```js
Object.getPrototypeOf(person1) === Person.prototype;//true
```

#### (3)实例.hasOwnProperty(属性)

检测一个属性是否存在于实例本身中，还是存在于原型中。

```js
person1.hasOwnProperty('name');//true
person2.hasOwnProperty('name');//false
```

#### (4) in
通过对象能够访问给定的属性，则返回true，**无论该属性是在实例还是在原型中**, **无论该属性是否可枚举**。

```js
'name' in person1;//true
'name' in person2;//true
```

#### (5) for...in
for...in循环返回对象所有的 **可枚举** 属性，**无论该属性是在实例还是在原型中**。

```js
for (let prop in person1) {
  console.log(`${prop}: ${person1[prop]}`);
} 
/** 输出:
name: Summer
age: 26
sayName: function() {
  console.log(this.name)
}
*/
```

#### (6) Object.keys(对象)
取得对象上所有的 **可枚举** 的 **实例** 属性组成的数组

```js
Object.keys(person1);//["name"]
Object.keys(person2);//[]
```

#### (7) Object.getOwnPropertyNames(对象)

获取对象的所有 **实例** 属性，**无论该属性是否可枚举**。

#### 方法(3)~(7)特点对比总结

方法             | 是否包含不可枚举属性 | 是否查找prototype链
-----------------|--------------------|-------------------
hasOwnProperty   | √           |×
in               | √           |√
for...in         | ×           |√
Object.keys()    | ×           |×
Object.getOwnPropertyNames()|√  |×

## 原型链

ECMAScript将**原型链**作为实现继承的主要方法。