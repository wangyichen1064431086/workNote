待整理：1-2参见《JavaScript高级程序设计》P586;3-5参见<http://mp.weixin.qq.com/s/asmzA8a1HuYQxyx8K0q-9g>

## 一、同源策略
<https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy>

**浏览器的**同源策略限制了 从一个源加载的文档或脚本与来自另一个源的资源的交互。它是隔离潜在恶意文档的关键安全机制。

具体限制：

1. 不能通过ajax的方法去请求不同源的资源。 
2. 浏览器中不同域的框架之间是不能进行js的交互操作的。

### 1. 同源的定义

如果两个页面具有相同的协议、域名和端口（如果有指定），则这两个页面具有相同的源。

> Tips:http协议默认端口是80，https默认端口是443。

### 2. 源的更改

脚本可以将 **document.domain**的值设置为当前域或当前域的父域。如果设置为超级域，那么超级域将用于后续的源检查。

Eg:对页面 http://store.company.com/dir/other.html 进行域的修改:

```js
document.domain = 'company.com';
```
该js执行后，该页面将会成功地通过对http://company.com/dir/page.html的同源检测。

#### 注意：
1. 只能将当前域设置为其父域，不能设置为其他域，如store.company.com可以设置为company.com,不能设置为othercompany.com
2. 对document.domain的赋值操作会导致端口号被重写为null。所以store.company.com:8080即使设置了document.domain = 'company.com',也还是不能和company.com通信。因为此时store.company.com的域名虽然是company.com,但端口号是null；而company.com的端口号可能是80；二者端口号不一致，还是不同源。所以必须在页面company.com也进行document.domain = document.domain，即双方都必须进行赋值操作，以确保端口号都为null
3. 使用document.domain来修改子域域名以访问其父域时，需要在父域和子域中设置document.domain都为父域的值。这样做是必要的，原因除了2.中所述原因以外，还因为不这样做可能会导致权限问题。
4. 修改document.domain的方法 **只适用于不同子域的框架(即iframe/frame)间的交互**，**不能用于Ajax**——即使设置了相同的document.domain，还是不能进行Ajax请求

### 3.正常的跨域网络访问
通常允许跨源资源嵌入（Cross-origin embedding）。

有以下这些情况：

#### (1)script标签嵌入跨源脚本

```html
<script src="...">
</script>
```

#### (2)rel=stylesheet的link标签嵌入css
```html
<link rel="stylesheet" href="...">
```
css跨域需要设置一个正确的Content-Type消息头。不同浏览器有不同限制。一般都可以成功跨源获取css资源。

#### (3)img嵌入图片,video/audio/object嵌入多媒体资源

#### (4) @font-face引入字体
一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。

#### (5)frame和iframe载入的任何资源

**iframe本身就是可以跨域的**。

站点可以使用 **X-Frame-Origins**消息头来阻止这种跨域。

##### Tips:关于X-Frame-Origins

[X-Frame-Origins](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options),是一个HTTP响应头，用来指示浏览器是否允许一个页面可以在iframe/frame/object中展示。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去。

可能值：

- DENY:不允许该页面在其他页面的frame/iframe中展示，无论那个其他页面和该页面是否是同源。
- SAMEORIGIN:该页面可以在同源页面的frame/iframe中展示。
- ALLOW-FROM uri:该页面可以在指定源的页面的frame/iframe中展示。

##### 测试
###### Test1: 嵌入baidu.com：

```html
<iframe width="1000" height="800" src="https://www.baidu.com"></iframe>
```
该页面可以正确地嵌入百度首页。但是控制台会报如下错误信息:

```s
 Uncaught DOMException: Blocked a frame with origin "https://www.baidu.com" from accessing a cross-origin frame
  at HTMLDocument.t...
```
可以发现，这些跨域错误信息都是由于需要进行js交互才出现的。
###### Test2: 嵌入ftchinese.com:

```html
<iframe width="1000" height="800" src="http://www.ftchinese.com"></iframe>
```

iframe区域展现的是空白。然后console控制台报错的信息为:

```s
Refused to display 'http://www.ftchinese.com/' in a frame because it set 'X-Frame-Options' to 'deny'.
```

### 4. 不允许的跨域网络访问

通常不允许跨域读操作(Cross-origin reads)。一般不能通过ajax的方法去请求不同源的资源。 浏览器中不同域的框架之间也是不能进行js的交互操作的。

但是通常可以通过内嵌资源等方式来巧妙的进行读写访问。Ajax经过特殊设置也可以实现跨域Ajax通信。不同源的框架间在一定条件限制下也可以通过一定手段实现js交互。


## 二、跨域技术
### 1.图像Ping

#### 启发
img标签可以从任何网页中加载图像，无论是否跨域。

#### 原理
图像Ping是与服务器进行简单、单向的跨域通信的一种方式。数据可以通过src地址的查询字符串发送到服务器。浏览器可以通过监听load和error事件，判断服务器是何时接收到响应。

#### 示例
最常用于跟踪用户点击页面的行为或广告曝光次数。

例如我们网站就是使用图像Ping给广告客户的服务器发送图像Ping来是的广告客户获取广告曝光次数的数据:

```js
var track = new Image();
track.onload = function() {
    window.parent.ga('send', 'event', 'iPhone web app launch ad', 'Sent', imp, {'nonInteraction':1});
};     
track.onerror = function() {
    window.parent.ga('send', 'event', 'iPhone web app launch ad', 'Fail', imp, {'nonInteraction':1});
};
track.src = imp;//imp为广告客户的广告曝光追踪地址，其实是一个白色小圆点图片
```
### 2.JSONP
#### 启发
script元素和img类似，都有能力不受限制地从其他域加载资源。
#### 原理
JSONP是JSON with Padding(参数式JSON或填充式JSON),就是被包含在函数中调用的JSON。

JSONP由两部分组成：数据 和 回调函数。 数据就是传入回调函数中的JSON数据。

JSONP的工作过程：为script标签的src指定一个跨域的URL（即JSONP服务的地址），并在URL中指定回调函数名称。因为JSONP服务最终返回的是有效的JavaScript代码，请求完成后会立即执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以，**jsonp是需要服务器端进行相应的配合的**。

#### 示例
以下是我写的[用koa和中间件koa-jsonp实现jsonP服务](https://github.com/wangyichen1064431086/koa-eg-jsonp/tree/master)的例子:



发起jsonp请求的前端页面相关代码为:

```html
 <script>
    function doSomething(jsonpData) {
      console.log(jsonpData);
    }
  </script>
  <script src="http://localhost:3000/?cb=doSomething"></script>

```
cb就是url中指定回调函数名称的参数，通常是callback,这个是需要在服务端设置的。

展示该前端页面的服务代码:
```js
const path = require('path');
const Koa = require('koa');
const Router = require('koa-router');
const logger = require('koa-logger');
const views = require('koa-views');

const app = new Koa();
const router = new Router();

app.use(logger());

app.use(views(path.resolve(__dirname,'views')));

async function showText(ctx) {
  await ctx.render('test');
}
router.get('/', showText);

app.use(router.routes());

app.listen(3001, () => {
  console.log('Listening 3001');
});
```

jsonp服务的代码:

```js
const Koa = require('koa');
const Router = require('koa-router');
const jsonp = require('koa-jsonp');
const logger = require('koa-logger');
const app = new Koa();
const router = new Router();

app.use(logger());
app.use(jsonp({
  callbackName:'cb'//指定回调函数名称的参数, defaults to 'callback'
}));

router.get('/', ctx => {
   ctx.body = {
    name:'Bonnie',
    age:26
  }
});

app.use(router.routes());

app.listen(3000, () => {
  console.log('Listening 3000');
});
```

页面的端口为3001,jsonp服务端口为3000，形成跨域，但是页面可以完美获取到jsonpData。

### 3.通过修改document.domain来跨子域
#### 问题

浏览器中不同域的框架之间是不能进行js的交互操作的。**脚本试图访问的框架内容必须遵守同源策略**。也就是说：

##### 对于同源的框架来说：

不同域的框架之间可以进行js交互。

- 父页面访问子页面：通过 **contentWindow**属性，父页面的脚本可以访问iframe元素所包含的子页面的window对象。contentDocument属性则引用了iframe中的文档元素（等同于使用contentWindow.document），但IE8-不支持。

- 子页面访问父页面：通过访问 **window.parent**，脚本可以从框架中引用它的父框架的window。

##### 对于非同源的框架来说：
脚本无法访问非同源的window对象的几乎所有属性。

该同源策略即适于父窗体访问子窗体的window对象，也适用于子窗体访问父窗体的window对象。

#### 问题验证
参见我写的[同源和跨域iframe交互操作的示例](https://github.com/wangyichen1064431086/crossorigin-modifydomain.git)。

##### （1）验证同源的框架间js互相访问window对象毫无障碍:

页面a的地址为http://localhost:3000/a;
页面b的地址为http://localhost:3000/b;
页面a中通过iframe嵌入页面b。

页面a代码：

```html
<div>我是a</div>
<iframe id="otherFrame" name="otherFrame" src={{iframeUrl}}></iframe>
<script>
  window.name = 'parentFrame';
  window.globalvarA = 'aaa';
  const otherFrame = document.getElementById('otherFrame');
  otherFrame.onload = function() {
    console.log('Parent console: Values of props from the child frame window:')
    console.log(`win:${otherFrame.contentWindow}`);
    console.log(`dom:${otherFrame.contentWindow.document}`);
    console.log(`name:${otherFrame.contentWindow.name}`);
    console.log(`globalvarB:${otherFrame.contentWindow.globalvarB}`);
  }
</script>
```

页面b代码:

```html
  <div>我是b</div>
  <script>
    window.globalvarB = 'bbb';
    console.log('Child console:Values of props from the parent frame window:')
    console.log(`win:${window.parent}`);
    console.log(`dom:${window.parent.document}`);
    console.log(`name:${window.parent.name}`);
    console.log(`globalvarA:${window.parent.globalvarA}`);
  </script> 
```

在http://localhost:3000/a的浏览器窗口可以看到a页面正确载入了b页面的内容。

在http://localhost:3000/a的控制台可以看到，a和b框架都有输出，b框架输出在a框架之前:

b框架输出结果:

```s
  Child console:Values of props from the parent frame window:
  win:[object Window]
  dom:[object HTMLDocument]
  name:parentFrame
  globalvarA:aaa
```

a框架输出结果:

```s
  Parent console: Values of props from the child frame window:
  win:[object Window]
  dom:[object HTMLDocument]
  name:otherFrame
  globalvarB:bbb
```

可见同源的父子框架之间js互相访问window对象确实非常顺畅。

##### (2)验证不同源的框架间js互相访问window对象存在障碍:

页面a的地址为http://localhost:3000/a;
页面b的地址为http://sub.localhost:3001/b;
页面a、b的嵌套关系不变，代码也不变，除了a中iframe的src值修改为b的新地址http://sub.localhost:3001/b

>Tips: koa中间件koa-subdomain可以完成对子域名的划分。

在http://localhost:3000/a的浏览器窗口可以看到a页面依然正确载入了b页面的内容。由此可以再次说明，**使用iframe载入html页面本身是可以跨域的**(如果没有对 'X-Frame-Options'响应头进行限制)。

在http://localhost:3000/a控制台，可以看到:

b框架输出:

```s
 Child console:Values of props from the parent frame window:
 Uncaught DOMException: Blocked a frame with origin "http://sub.localhost:3001" from accessing a cross-origin frame.
    at http://sub.localhost:3001/b:14:31 (这一行正好是: console.log(`win:${window.parent}`);)
```


框架a输出:

```s
Parent console: Values of props from the child frame window:
Uncaught DOMException: Blocked a frame with origin "http://localhost:3000" from accessing a cross-origin frame.
    at HTMLIFrameElement.otherFrame.onload (http://localhost:3000/a:19:35)
```

可见不同源的父子框架之间js **不能获取到对方window对象及其属性和方法**。(html5中的postMessage方法是一个例外)

#### 解决原理
将页面的**document.domain**的值设置为当前域或当前域的父域。详见 一、中 2. 源的更改。

#### 解决实践
在上述a.html和b.html中的script标签中的第一行加上:

```js
document.domain = 'localhost'
```
理论上在本地测试应该可以成功了。但事实上会报错:

```s
Failed to set document.domain to localhost. 'localhost' is a top-level domain
```

其实是因为localhost这个域名很特殊，这样设置不合法。

解决办法是通过修改C:\Windows\System32\drivers\etc\hosts文件，加上一行:

```s
127.0.0.1   test.com
```
将localhost换成合法域名。

修改域名后，a可以通过http://test.com:3000/a访问。
但是，koa-subdomain中间件会失效，访问b还是只有http://sub.localhost:3001/b，http://sub.test.com:3001/b并不会生效。

如果想要看到跨域结果，还是去非本地的服务器上测试吧~~~

### 4.使用window.name来进行跨域

### 5.使用HTML5中新引进的window.postMessage方法来跨域传送数据

### 6.fetch跨域设置

#### Access-Control-Allow-Origin
<https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin>

响应头设置Access-Control-Allow-Origin：https://backyard.ftchinese.com

#### fetch的mode字段

设为

```js
mode: 'cors'
```

<https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch>

## 参考文档与博客

<https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy>

<https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options>

<https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe>

<https://www.jianshu.com/p/b587dd1b7086>
<https://mp.weixin.qq.com/s/asmzA8a1HuYQxyx8K0q-9g?>

<https://www.techwalla.com/articles/how-to-change-your-local-host-name>


《JavaScript高级程序设计》21.5