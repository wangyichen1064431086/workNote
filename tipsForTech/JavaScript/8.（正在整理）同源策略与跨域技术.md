待整理：1-2参见《JavaScript高级程序设计》P586;3-5参见<http://mp.weixin.qq.com/s/asmzA8a1HuYQxyx8K0q-9g>

## 一、同源策略
<https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy>

**浏览器的**同源策略限制了 从一个源加载的文档或脚本与来自另一个源的资源的交互。它是隔离潜在恶意文档的关键安全机制。

具体限制：

1. 不能通过ajax的方法去请求不同源的资源。 
2. 浏览器中不同域的框架之间是不能进行js的交互操作的。

### 1. 同源的定义

如果两个页面具有相同的协议、域名和端口（如果有指定），则这两个页面具有相同的源。

> Tips:http协议默认端口是80，https默认端口是443。

### 2. 源的更改

脚本可以将 **document.domain**的值设置为当前域或当前域的父域。如果设置为超级域，那么超级域将用于后续的源检查。

Eg:对页面 http://store.company.com/dir/other.html 进行域的修改:

```js
document.domain = 'company.com';
```
该js执行后，该页面将会成功地通过对http://company.com/dir/page.html的同源检测。

#### 注意：
1. 只能将当前域设置为其父域，不能设置为其他域，如store.company.com可以设置为company.com,不能设置为othercompany.com
2. 对document.domain的赋值操作会导致端口号被重写为null。所以store.company.com:8080即使设置了document.domain = 'company.com',也还是不能和company.com通信。因为此时store.company.com的域名虽然是company.com,但端口号是null；而company.com的端口号可能是80；二者端口号不一致，还是不同源。所以必须在页面company.com也进行document.domain = document.domain，即双方都必须进行赋值操作，以确保端口号都为null
3. 使用document.domain来修改子域域名以访问其父域时，需要在父域和子域中设置document.domain都为父域的值。这样做是必要的，原因除了2.中所述原因以外，还因为不这样做可能会导致权限问题。
4. 修改document.domain的方法 **只适用于不同子域的框架(即iframe/frame)间的交互**，**不能用于Ajax**——即使设置了相同的document.domain，还是不能进行Ajax请求

### 3.正常的跨域网络访问
通常允许跨源资源嵌入（Cross-origin embedding）。

有以下这些情况：

#### (1)script标签嵌入跨源脚本

```html
<script src="...">
</script>
```

#### (2)rel=stylesheet的link标签嵌入css
```html
<link rel="stylesheet" href="...">
```
css跨域需要设置一个正确的Content-Type消息头。不同浏览器有不同限制。一般都可以成功跨源获取css资源。

#### (3)img嵌入图片,video/audio/object嵌入多媒体资源

#### (4) @font-face引入字体
一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。

#### (5)frame和iframe载入的任何资源

**iframe本身就是可以跨域的**。

站点可以使用 **X-Frame-Origins**消息头来阻止这种跨域。

##### Tips:关于X-Frame-Origins

[X-Frame-Origins](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options),是一个HTTP响应头，用来指示浏览器是否允许一个页面可以在iframe/frame/object中展示。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去。

可能值：

- DENY:不允许该页面在其他页面的frame/iframe中展示，无论那个其他页面和该页面是否是同源。
- SAMEORIGIN:该页面可以在同源页面的frame/iframe中展示。
- ALLOW-FROM uri:该页面可以在指定源的页面的frame/iframe中展示。

##### 测试
###### Test1: 嵌入baidu.com：

```html
<iframe width="1000" height="800" src="https://www.baidu.com"></iframe>
```
该页面可以正确地嵌入百度首页

###### Test2: 嵌入ftchinese.com:

```html
<iframe width="1000" height="800" src="http://www.ftchinese.com"></iframe>
```

iframe区域展现的是空白。然后console控制台报错的信息为:
```s
Refused to display 'http://www.ftchinese.com/' in a frame because it set 'X-Frame-Options' to 'deny'.
```

### 4. 不允许的跨域网络访问

通常不允许跨域读操作(Cross-origin reads)。Ajax一般是不能跨域的。

但是通常可以通过内嵌资源等方式来巧妙的进行读写访问。Ajax经过特殊设置也可以实现跨域Ajax通信。


## 二、跨域技术
### 1.图像Ping

#### 启发
img标签可以从任何网页中加载图像，无论是否跨域。

#### 原理
图像Ping是与服务器进行简单、单向的跨域通信的一种方式。数据可以通过src地址的查询字符串发送到服务器。浏览器可以通过监听load和error事件，判断服务器是何时接收到响应。

#### 示例
最常用于跟踪用户点击页面的行为或广告曝光次数。

例如我们网站就是使用图像Ping给广告客户的服务器发送图像Ping来是的广告客户获取广告曝光次数的数据:

```js
var track = new Image();
track.onload = function() {
    window.parent.ga('send', 'event', 'iPhone web app launch ad', 'Sent', imp, {'nonInteraction':1});
};     
track.onerror = function() {
    window.parent.ga('send', 'event', 'iPhone web app launch ad', 'Fail', imp, {'nonInteraction':1});
};
track.src = imp;//imp为广告客户的广告曝光追踪地址，其实是一个白色小圆点图片
```
### 2.JSONP
#### 启发
script元素和img类似，都有能力不受限制地从其他域加载资源。
#### 原理
JSONP是JSON with Padding(参数式JSON或填充式JSON),就是被包含在函数中调用的JSON。

JSONP由两部分组成：数据 和 回调函数。 数据就是传入回调函数中的JSON数据。

JSONP的工作过程：为script标签的src指定一个跨域的URL（即JSONP服务的地址），并在URL中指定回调函数名称。因为JSONP服务最终返回的是有效的JavaScript代码，请求完成后会立即执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以，**jsonp是需要服务器端进行相应的配合的**。

#### 示例
以下是我写的用koa和中间件koa-jsonp实现jsonP服务的例子:

<https://github.com/wangyichen1064431086/koa-eg-jsonp/tree/master>

发起jsonp请求的前端页面相关代码为:

```html
 <script>
    function doSomething(jsonpData) {
      console.log(jsonpData);
    }
  </script>
  <script src="http://localhost:3000/?cb=doSomething"></script>

```
cb就是url中指定回调函数名称的参数，通常是callback,这个是需要在服务端设置的。

jsonp服务的代码:

```js
const Koa = require('koa');
const Router = require('koa-router');
const jsonp = require('koa-jsonp');
const logger = require('koa-logger');
const app = new Koa();
const router = new Router();

app.use(logger());
app.use(jsonp({
  callbackName:'cb'//指定回调函数名称的参数, defaults to 'callback'
}));

router.get('/', ctx => {
   ctx.body = {
    name:'Bonnie',
    age:26
  }
});

app.use(router.routes());

app.listen(3000, () => {
  console.log('Listening 3000');
});
```

### 3.通过修改document.domain来跨子域

脚本试图访问的框架内容必须遵守同源策略，并且无法访问非同源的window对象的几乎所有属性。同源策略同样适用于子窗体访问父窗体的window对象。跨域通信可以通过window.postMessage来实现。


### 4.使用window.name来进行跨域

### 5.使用HTML5中新引进的window.postMessage方法来跨域传送数据

### 6.fetch跨域设置

#### Access-Control-Allow-Origin
<https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin>

响应头设置Access-Control-Allow-Origin：https://backyard.ftchinese.com

#### fetch的mode字段

设为

```js
mode: 'cors'
```

<https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch>

## 参考文档与博客

<https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy>

<https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options>

<https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe>

https://www.jianshu.com/p/b587dd1b7086
<https://mp.weixin.qq.com/s/asmzA8a1HuYQxyx8K0q-9g?>


《JavaScript高级程序设计》21.5