## 概念理解

在**定义**某函数的词法作用域**以外**调用该函数时，该函数依然保留有对其定义时的词法作用域的引用。那么该函数可以叫做闭包。

**NOTE**：这里的**以外**有两种含义：

### 1. 空间上的以外。

Eg:模块模式。
```
  function CoolModule(x) {
    function doSomething() {
      ...
    }
    return {
      doSomething
    }
  }
  CooleModule(x).doSomething();  
```

### 2. 时间上的以外。

Eg:setTimeout中的。
```
  for (var i = 1; i <= 5; i++) {
		setTimeout(function timer() {
			console.log(i);
		}, i * 1000);
  }
```
该代码段会输出 6 6 6 6 6

想要得到想要的1 2 3 4 5，必须这样：
```
  for (var i = 1; i <= 5; i++) {
      (function(j) {
        setTimeout(function timer() {
          console.log(j);
        }, j * 1000);
      })(i);
  }
```

#### 参考《你所不知道的JavaScript》上卷 Part1 Chapter5

## 闭包经典问题
### 1. 思考下面的代码段：

```js
	for(var i=0;i<5;i++){
	    var btn=document.createElement('button');
	    btn.appendChild(document.createTextNode('Button'+i));//document.createTextNode(<text>)方法：创建一个带有指定内容的新Text对象（即上述button元素上写的文字）
	    btn.addEventListener(//为元素添加事件监听器
	      'click',
	       function(){
	          console.log(i);
	        }
	    );
	    document.body.appendChild(btn);
	}
```

a. 点击“Button4”后输出什么？如何使得输出和预期相同

b. 给出一个可以和预期相同的写法。

**答案：** 

a. 输出5，因为形成了闭包，循环结束后，i为5，所有按钮点击都是5

b. 有两种思路可以解决该问题：

(1) 元素属性添加法
	```js
	for(var i=0;i<5;i++){
	    var btn=document.createElement('button');
	    btn.appendChild(document.createTextNode('Button'+i));
	    btn.addEventListener(
	      'click',
	       function(e){
	          for(var i=0;i<5;i++){
	            if (e.target.innerHTML=='Button'+i) {
	                console.log(i);
	            }
	          }
	        }
	    );
	    document.body.appendChild(btn);//document.A.appendChild(B)方法：将B元素添加为A的子元素
	}
	```
作者大神的方法：

[这10道javascript笔试题](http://www.cnblogs.com/zichi/p/4359786.html)你都会么 中的第 8 题。

参考可以得出其他方法：
2. 闭包

这是错误的：

	```
	for(var i=0;i<5;i++){
	    var btn=document.createElement('button');
	    btn.appendChild(document.createTextNode('Button'+i));
	    btn.addEventListener(
	      'click',
	       (function(i){
	          (function(){
	            console.log(i);
	          })();
	       })(i)
	    );
	    document.body.appendChild(btn);//document.A.appendChild(B)方法：将B元素添加为A的子元素
	}
	```
这也是错误的：
	
	```
	for(var i=0;i<5;i++){
	    var btn=document.createElement('button');
	    btn.appendChild(document.createTextNode('Button'+i));
	    btn.addEventListener(
	      'click',
	       (function(i){
	            console.log(i);
	       })(i)
	    );
	    document.body.appendChild(btn);//document.A.appendChild(B)方法：将B元素添加为A的子元素
	}
	```
这才是正确的闭包：

	```
	for(var i=0;i<5;i++){
	    var btn=document.createElement('button');
	    btn.appendChild(document.createTextNode('Button'+i));
	    (function(a){
	        btn.addEventListener(
	            'click',
	            function () {
	                console.log(a);
	            }
	        )
	    })(i);
	    document.body.appendChild(btn);//document.A.appendChild(B)方法：将B元素添加为A的子元素
	}
	```
**其实，闭包就是在要引用外部变量i的函数外面加上一个 用作块级作用域的匿名函数**
	
	```
	(function(i){
		//某某内部使用了i的函数
	})(i);
	```
### 13) 引申  [这10道javascript笔试题](http://www.cnblogs.com/zichi/p/4359786.html)你都会么 中的第 8 题。

 实现一段脚本，使得点击对应链接alert出相应的编号

1. DOM	污染法
通过给document元素对象添加了属性值，故污染了DOM

		```
		 var lis = document.links;// 属于DOM Document对象，非Dom Element对象,返回文档里具备href属性的a和area元素的对象。参见《HTML5权威指南》P545
		    for(var i = 0, length = lis.length; i < length; i++) {
		      lis[i].index = i;//此index为自己设置的任意变量值，可任意替换为myindex等等，也可使用固有的元素对象属性，如id等
		      lis[i].onclick = function( ) {
		        alert(this.index);//也可用function(e),后面this换为e.target
		      };
		
		    }
		```
该法自己的习惯写法为:

		```
		 var lis = document.getElementsByTagName("a");// 属于DOM Document对象，非Dom Element对象
		    for(var i = 0; i <lis.length; i++) {
		      lis[i].id = i;//把number型的i赋值给id后，直接转换为了string型，因为id都是string型的。
		      lis[i].onclick = function(e) {
		        alert(e.target.id);
		      };
		    }
		```

2. 使用闭包

		```
		var lis=document.links;
		
		for(var i=0,len=lis.length;i<len;i++){
		    (function(a){
		        lis[a].onclick=function(){
		            alert(a);
		        };
		    })(i);
		}
		```

3.我的惯用方法(事件循环索引法***自己命的名***)
```
var lis=document.links;

for(var i=0,len=lis.length;i<len;i++){
    lis[i].onclick=function(){
        for(var j=0;j<lis.length;j++){
            if (this==lis[j]) {
                alert(j);
            }
        }
    };
}
```
其实，上述j也可就写作i,因为内部循环参数是在局部函数中的，故循环完成后自动销毁，对外部i没有影响。

更多关于闭包[其实闭包并不高深莫测](http://web.jobbole.com/84456/)


### 实践总结2
这是对的：
```
const articleLists = Array.from(document.querySelectorAll('.article-list .article'));
  articleLists.forEach((elem, index) => {
    (function() {
       elem.addEventListener('click', function(){
        console.log(index);
        const labelForListArticle = `Article: ${index+1}`;
        ga('send', 'event', category, action, labelForListArticle);
        console.log('click ', labelForListArticle);
       })
    })(index);
  });
```

这是错的
```
const articleLists = Array.from(document.querySelectorAll('.article-list .article'));
  articleLists.forEach((elem, index) => {
    (function(i) {
       elem.addEventListener('click', function(){
        console.log(i);
        const labelForListArticle = `Article: ${i+1}`;
        ga('send', 'event', category, action, labelForListArticle);
        console.log('click ', labelForListArticle);
       })
    })(index);
  });
```

这也是错的
```
const articleLists = Array.from(document.querySelectorAll('.article-list .article'));
  articleLists.forEach((elem, index) => {
	 const labelForListArticle = `Article: ${index+1}`;
    (function(label) {
       elem.addEventListener('click', function(){
        console.log(index);
        ga('send', 'event', category, action, label);
        console.log('click ', label);
       })
    })(labelForListArticle);
  });
```