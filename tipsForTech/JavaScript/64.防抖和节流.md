参考:
<https://jinlong.github.io/2016/04/24/Debouncing-and-Throttling-Explained-Through-Examples/>

<https://jinlong.github.io/2016/04/24/Debouncing-and-Throttling-Explained-Through-Examples/>

## 一、防抖
将多次计算合并为一次计算。

如果在频繁的事件回调中做复杂计算，可能导致页面卡顿，不如将多次计算合并成一次计算，只在一个精确点做操作。

> Tip: 是一个 JavaScript 工具库，它提供了一整套函数式编程的实用功能，但是没有扩展任何 JavaScript 内置对象。 文档<http://www.bootcss.com/p/underscore/>

underscore库的防抖动源码：
```js
/**
 * @param {function} func 用户需要执行的函数
 * @param {array} funcargs 用户需要执行的函数的参数
 * @param {number} wait 时间间隔
 * @param {boolean} immediate 是否立即调用函数
 * @return {function} 返回用户调用的函数
 */
_debounce = function(func, funcargs, wait, immediate) {
  var timeout, context, timestamp,result;
  
  //定义定时器的回调函数
  var later = function() {
    //和上一次时间戳比较，得到当前间隔：
    console.log('exect later');
    var last = Date.now() - timestamp;//当前点击时间和上一次点击时间只差
    console.log('last:',last);
    //如果当前间隔少于wait，且大于0,则使用setTimeout过（wait-last）再执行本函数later
    if (last < wait && last >= 0) {
      console.log(`last ${last} < wait ${wait}`);
      console.log(`wait more: ${wait-last}`);
      timeout = setTimeout(later, wait-last)
    } else {
    //如果当前时间间隔大于wait，那么就可以执行回调函数了
     console.log(`last ${last} >  wait ${wait}`);

      timeout = null;
      if(!immediate) {
        console.log('exect func');
        result = func.apply(context, funcargs);
        if(!timeout) {
          context = null;
        }
      }
    }
  }

  return function() {
    context = this;
    //console.log(arguments);
    //args = arguments; 这里是无法获取func的参数的，因为此处arguments为最外层的事件监听函数的参数event
    timestamp = Date.now();

    //如果要求立即执行函数 且 定时器不存在,那么就立即执行func
    var callNow = immediate && !timeout;
    if(callNow) {
      result = func.apply(context, funcargs);
      context = null;
    }

    //如果定时器不存在就创建一个
    if(!timeout) {
      console.log('here');
      timeout = setTimeout(later, wait);
    }

    return result;//callNow为true则直接执行func
  }
}

// test:结果是每次resize,只有松开鼠标才有一次打印haha
window.addEventListener('resize', 
  _debounce((param)=>{
    console.log(param);
  }, ['haha'],1000, false)
);

//结果就是1s内最多只能点击1次
document.addEventListener('click', 
  _debounce((param)=>{
    console.log(param);
  }, ['haha'],1000, false)
);


```

## 二、节流
节流是将多次执行变成每隔一段时间执行一次。

```js
/**
 * @param {function} func 用户需要执行的函数
 * @param {array} funcargs 用户需要执行的函数的参数
 * @param {number} wait 时间间隔
 * @param {object} options 如果想忽略一开始函数的调用，传入{leading: false};如果想忽略结尾函数的调用，传入{trailing: false}
 * @return {function} 返回用户调用的函数
 */
_throttle = function(func, funcargs, wait, options) {
  var context,result;
  var timeout = null;

  //之前的时间戳设为0
  var previous = 0;
  if(!options) {
    options = {};
  }

  //定义定时器回调函数
  var later = function() {
    console.log('exect later');
   
    //如果设置了leading，那么previous时间戳就为0，否则为当前时间戳
    previous = options.leading === false ? 0 :Date.now();

    timeout = null;

    result = func.apply(context, funcargs);

    if(!timeout) {
      context = null;
    }
  }

  return function() {
    context = this;
    
    //获得当前时间戳
    var now = Date.now();

    if(!previous && options.leading === false) {
      previous = now;
    }
    //计算剩余时间
    var remaining = wait - (now - previous); //首次进入previous为0,所以如果没有设置不要leading(leading为false)，那么remaining就是0，即一开始就可以调用

    //如果剩余时间大于wait
    if(remaining <= 0 || remaining > wait) {
      if(timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, funcargs);
      if(!timeout) {
        context = null;
      }
    } else if (!timeout && options.trailing!== false) {
      //如果没有定时器了且没有不要trailing，那么就隔remaining的时间再执行一次later
      timeout = setTimeout(later, remaining);
    }
    return result;//否则直接执行回调
  }
}

// test:结果是每隔1s输出一次
window.addEventListener('resize', 
_throttle((param)=>{
    console.log(param);
  }, ['haha'],1000)
);

//结果是如果3s内点击了10次，那其实只点了3次
document.addEventListener('click', 
_throttle((param)=>{
    console.log(param);
  }, ['haha'],1000)
);
```
使用window.requestAnimationFrame等于16ms一次节流
```js
window.addEventListener('resize', ()=> {
  window.requestAnimationFrame(()=>{
    console.log(1);
  })
});
```
等于:
```js
window.addEventListener('resize', 
_throttle(()=>{
    console.log(1);
  },[], 16)
);
```