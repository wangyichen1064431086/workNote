## 一、NodeList vs HTMLCollection
### 1.NodeList

#### 简介
NodeList是一个 **节点**的集合, 是由 Node.childNodes 和 document.querySelectorAll 返回的。

##### 特点
###### (1) 类数组
它是一种类数组对象，用于保存一组有序的节点，可以通过位置(childNodes[index]或childNodes.item(index)) 来访问这些节点, 但它 **并不是Array实例**。 

###### (2)有时实时有时静态

- childNodes是实时的。
- querySelectorAll是静态的。

#### 用例

基本用法:

```js
var firstChild = someNode.childNodes[0];
var secondChild = someNode.childNodes.item(1);
var thirdChild = someNode.childNodes.item('#id');
var nodeCount = someNode.childNodes.length;
```

将nodeList转化为Array：

```js
var nodeListArr = Array.prototype.slice.call(someNode.childNodes,0);
//es6
var nodeListArr = Array.from(someNode.childNodes);
```

###  2. HTMLCollection

#### 简介
HTMLCollection 接口表示一个包含了 **元素**（元素顺序为文档流中的顺序）的通用集合（generic collection）

以下集合为HTMLCollection:

- document.anchors:文档中所有带name属性的a元素
- document.forms:文档中所有form元素。同document.getElementsByTagName('form')
- document.images:文档中所有img元素。同document.getElementsByTagName('img')
- document.links:文档中所有带href的a元素。

#### 用例
文档中有一个form元素，id为'myForm'。

```js
document.forms//是一个HTMLCollection

//获取该form的方法有以下4种
document.forms[0]
document.forms.item(0)

document.forms['myForm']
document.forms.namedItem('myForm');

document.images;  // This is an HTMLCollection


```
###  3.NodeList与HTMLCollection比较


<https://www.jianshu.com/p/f6ff5ebe45fd>

HTMLCollection与NodeList都是DOM节点的集合，两者都属于Collections范畴，二者的共同点有:

- 都是类数组对象，都有length属性
- 都有共同的方法：item，可以通过item(index)或者item(id)来访问返回结果中的元素
- 都是实时变动的（live），document上的更改会反映到相关对象上（例外：document.querySelectorAll返回的NodeList不是实时的）

两者的区别在于：

- 方法略有差异：HTMLCollection比NodeList多了一个namedItem方法，其他方法保持一致
- 包含节点类型不同：NodeList可以包含任何节点类型(Node)，HTMLCollection只包含元素节点（ElementNode）

## 二.、parentNode vs parentElement
### Node.parentNode
<https://developer.mozilla.org/zh-CN/docs/Web/API/Node/parentNode>
返回指定的节点在DOM树中的父节点.

parentNode是指定节点的父节点.该节点的父节点可能是一个元素(Element )节点,也可能是一个文档(Document )节点,或者是个文档碎片(DocumentFragment)节点.


### Node.parentElement
<https://developer.mozilla.org/zh-CN/docs/Web/API/Node/parentElement>

返回当前节点的父 **元素节点**,如果该元素没有父节点,或者父节点不是一个元素节点.则 返回null.

### parentElement和parentNode的比较
<https://stackoverflow.com/questions/8685739/difference-between-dom-parentnode-and-parentelement>

parentElement is new to Firefox 9 and to DOM4, but it has been present in all other major browsers for ages.

In most cases, it is the same as parentNode. The only difference comes when a node's parentNode is not an element. If so, parentElement is null.

As an example:
```
document.body.parentNode; // the <html> element
document.body.parentElement; // the <html> element

document.documentElement.parentNode; // #document
document.documentElement.parentElement; // null
```

Since the < html> element (document.documentElement) doesn't have a parent that is an element, parentElement is null. (There are other, more unlikely, cases where parentElement could be null, but you'll probably never come across them.)


## 三、 childNodes vs children

### Node.childNodes

Node.childNodes 返回包含指定节点的子节点的集合(NodeList)，该集合为即时更新的集合（live collection）。


### Node.children

<https://developer.mozilla.org/zh-CN/docs/Web/API/ParentNode/children>



ParentNode.children 是一个只读属性，返回 一个Node的子elements ，也是一个动态更新的 HTMLCollection。

### Node.childNodes和Node.children的比较
Node.childNodes返回NodeList； Node.children返回HTMLCollection。更多细节参见一、NodeList vs HTMLCollection

## 四、Node.firstChild/lastChild vs Node.previousSibling/nextSibling
###  Node.firstChild/lastChild
#### 简介
Node.firstChild/lastChild只读属性返回节点的第一个/最后一个子节点，如果节点是无子节点，则都为null。

它们分别对应Node.childNodes的第一个后最后一个节点。即someNode.firstChild等于someNode.childNodes[0];someNode.lastChild等于someNode.childNodes[someNode.childNodes.length-1]

要注意fistChild和lastChild也 **可以是文本节点**。

>Tips:使用 document.write 语句插入的两个元素之间不会有空白。

### 用例

```html
<p id="para-01">
  <span>First span</span>
</p>

<script type="text/javascript">
  var p01 = document.getElementById('para-01'); 
  alert(p01.firstChild.nodeName)//#text 
</script>
```
上例得到的是文本节点，因为在p标签和span标签之前,有一个换行符和多个空格充当了一个文本节点.

```html
<p id="para-01"><span>First span</span></p>

<script type="text/javascript">
  var p01 = document.getElementById('para-01');
  alert(p01.firstChild.nodeName)
</script>
```
上例得到的是span元素节点。因为空白符已经被移除了。

### Node.previousSibling/nextSibling
Node.previousSibling/nextSibling只读属性返回其前一个/后一个兄弟节点。即返回其父节点的childNodes列表中紧跟在该节点之前/之后的节点。

列表中第一个节点的previousSibling为null,最后一个节点的nextSibling为null。

如果列表中只有一个节点，则其previousSibling和nextSibling都为null

和Node.fistChild/lastChild一样，previousSibling和nextSibling也 **可以是文本节点**。


## 五. Node.appendChild() vs ParentNode.append()
### Node.appendChild()
Node.appendChild() 方法将一个节点添加到指定父节点的子节点列表末尾，并返回添加的节点

> 注意:如果被插入的节点已经存在于当前文档的文档树中,则那个节点会首先 **从原先的位置移除**,然后再插入到新的位置.如果你需要保留这个子节点在原先位置的显示,则你需要先用 **Node.cloneNode** 方法复制出一个节点的副本,然后在插入到新位置.

```js
var child = node.appendChild(child);
```

### *(实验中的功能) ParentNode.append()
<https://developer.mozilla.org/zh-CN/docs/Web/API/ParentNode/append>

 ParentNode.append 方法在 ParentNode的最后一个子节点之后插入一组 Node 对象或 DOMString 对象。被插入的 DOMString 对象等价为 Text 节点。
 
与 Node.appendChild() 的差异：
 
- ParentNode.append() 允许你也追加  DOMString 对象，而 Node.appendChild() 只接受 Node 对象。
- ParentNode.append() 没有返回值，而 Node.appendChild() 返回追加的 Node 对象。
- ParentNode.append() 可以追加几个节点和字符串，而 Node.appendChild() 只能追加一个节点。

## 六. 其他节点操作办法

### Node.insertBefore()
Node.insertBefore() 方法在参考节点之前插入一个节点作为一个指定父节点的子节点。

```js
var insertedElement = parentElement.insertBefore(newElement, referenceElement);
```

> 注意：如果referenceElement为null则newElement将被插入到子节点的末尾。

> 注意：如果newElement已经在DOM树中，newElement首先会从DOM树中移除

### Node.replaceChild()
Node.replaceChild()方法用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。

```js
var replacedNode = parentNode.replaceChild(newChild, oldChild);
```
- newChild: 用来替换 oldChild 的新节点。如果该节点已经存在于DOM树中，则它会被从原始位置删除。
- oldChild: 被替换掉的原始节点。
- replacedNode 和oldChild相等。

### Node.cloneNode()
Node.cloneNode() 方法返回调用该方法的节点的一个副本。其有一个Boolean参数，表示是否执行深复制。

```js
var dupNode = node.cloneNode(deep);
```

- node:将要被克隆的节点
- dupNode:克隆生成的副本节点
- deep: TYPE Boolean， 可选， 默认为false执行浅复制。是否采用深度克隆,如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身.


## 七.textContent.innerHTML、innterText的区别
<https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent>
P294/301
## 七、延伸话题: 使用innerHTML提升性能（相对CreateElement)
<http://blog.csdn.net/jjfat/article/details/9127509>

#### innerHTML的性能优化写法
<https://hk.saowen.com/a/3cda3721c055034184b9bf7ac189996600c1692fe3e6dee999f2f2208b543883>

## 6. DOM节点的添加、复制、删除
一个节点要想添加到两个父节点后面，这个节点必须要深复制一次：

```js
const switchStyle = document.createElement("style");
const switchStyleCopy = switchStyle.cloneNode(true);//深复制

innerIframeWindowHead.appendChild(switchStyle);
outerIframeWindowHead.appendChild(switchStyleCopy);
```
